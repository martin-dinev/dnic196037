<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CodeHelper SmartStrings</title>
    {% load static %}
    <script src="{% static 'codemirror-5.65.8/lib/codemirror.js' %}"></script>
    <link rel="stylesheet" href="{% static 'codemirror-5.65.8/lib/codemirror.css' %}">
    <script src="{% static 'codemirror-5.65.8/mode/clike/clike.js' %}"></script>
    <link href="{% static 'bootstrap-5.2.0-dist/css/bootstrap.css' %}" rel="stylesheet">
    <script src="{% static 'bootstrap-5.2.0-dist/js/bootstrap.bundle.js' %}"></script>
</head>
<body>


{# FORMS #}
<div>
    {# RETURN TO EDITOR #}
    <form id="return_to_editor_form" action="/" method="POST">
        {% csrf_token %}
        <input type="hidden" name="code" value=""/>
    </form>
</div>
<section class="container-fluid bg-primary min-vh-100 align-items-center d-flex px-0 flex-wrap">

    {# BUTTONS NAVBAR #}
    <div class="container-fluid align-items-center d-flex justify-content-around" style="height: 10vh">

        {# RETURN TO EDITOR #}
        <button type="button" onclick="return_to_editor_form();"
                class="btn btn-light"> Return to editor
        </button>


        <button type="button" class="btn btn-light disabled">
            Run Code <span class="h6">#soon, it's coming slowly</span>
        </button>
    </div>

    {# CODE MIRROR #}
    <style>
        .CodeMirror {
            padding-left: 0;
            padding-right: 0;
            height: 100%;
        }
    </style>
    <div class="container-fluid px-0" style="height: 90vh">
        <div class="h-100" id="text_area" style="margin-top: 0;"></div>
    </div>

</section>

{# FORM SCRIPTS #}
<script>
    function return_to_editor_form() {
        let my_form = document.forms['return_to_editor_form'];
        my_form.elements["code"].value = myCodeMirror.getValue();
        document.getElementById("return_to_editor_form").submit();
    }
</script>

{# CODE MIRROR SCRIPTS #}
<script>
    let myCodeMirror = CodeMirror(document.getElementById('text_area'), {
        value: `{{ code|default:"#include<iostream>\nusing namespace std;\nint main() {\n\t\n}\n"|safe}}`,
        indentUnit: 4,
        lineNumbers: true,
        styleActiveLine: {nonEmpty: true},
        matchBrackets: true,
        mode: 'text/x-c++src',
        readOnly: true,
        gutters: ["CodeMirror-linenumbers", {"className": "buttons", "style": "width:18px;"}],
    });
    myCodeMirror.setSize("100%", "100%");
</script>

{# LINES SCRIPTS #}
<style>

    .CodeMirror-code > div div.buttons-gutter.other-marker {
        visibility: hidden;
        background-color: #0dcaf0;
    }

    .CodeMirror-code > div:hover div.buttons-gutter.other-marker {
        visibility: visible;
        background-color: #0dcaf0;
    }

    .CodeMirror-code > div div.buttons-gutter:not(.other-marker) {
        visibility: visible;
        background-color: yellow;
    }

    .CodeMirror-code > div:hover div.buttons-gutter:not(.other-marker) {
        visibility: visible;
        background-color: #0dcaf0;
    }

    .CodeMirror-code div.buttons-gutter:hover > .dropdown-menu {
        display: block;
        left: 100%;

    }


    .CodeMirror-code .buttons-gutter .dropdown-toggle {
        color: black;
        background-color: inherit;
    }

    .submenu:hover > .dropdown-submenu {
        display: block;
    }
</style>
<script src="{% static 'markers.js' %}"></script>
<script>

    function makeButtonMarker(n, line_type) {
        let marker;
        if (line_type === "for")
            marker = for_marker();
        else if (line_type === "if")
            marker = if_marker();
        else if (line_type === "main")
            marker = main_marker();
        else if (line_type === "int")
            marker = int_marker();
        else
            marker = other_marker();
        myCodeMirror.getDoc().setGutterMarker(n, "buttons", marker);
    }

    function gutterWidth() {
        return myCodeMirror.getGutterElement().clientWidth;
    }

    function addVariableWidget(n) {
        let currentLine = myCodeMirror.getDoc().getLine(n);
        let int_position = currentLine.indexOf("int");
        let int_declaration_end = int_position + currentLine.slice(int_position).indexOf(";");
        currentLine = currentLine.slice(int_position, int_declaration_end);

        let offset = myCodeMirror.charCoords({"line": n, "ch": int_position}).left - gutterWidth();

        currentLine.trim().slice(4).trim().split(",").map(p => p.split("=").map(it => it.trim()))
            .map(p => ({"name": p[0], "value": (p.size === 1 ? "undef" : p[1])}))
            .forEach(p => {
                myCodeMirror.getDoc().addLineWidget(n, int_widget(p.name, p.value, offset));
            });
    }

    {% for line in lines %}
        makeButtonMarker({{ forloop.counter0 }}, "{{ line }}");
        {% if line == "int" or line == "for" %}
            addVariableWidget({{ forloop.counter0 }});
        {% endif %}
    {% endfor %}

</script>

{# EXECUTE CODE ON CLIENT SIDE #}
<script>
    let runnable = {{ runnable|safe }};
    let steps = []
    let variables = []
    let variables_count = []

    function event_step(line, action, name, value = undefined) {
        steps.push({"line": line, "action": action, "name": name, "value": value});
    }

    function new_variable(line, variable_name, variable_value) {
        return {"line": line, "name": variable_name, "value": variable_value};
    }

    function get_variable(variable_name) {
        for (const variable of variables) {
            if (variable.name === variable_name)
                return variable;
        }
        return undefined;
    }

    function walk(run_object) {
        if (run_object.kind === "scope") {
            variables_count.push(0);
            for (const exec_element of run_object.exec) {
                walk(exec_element);
            }
            let count = variables_count.pop();
            while (count > 0) {
                count -= 1;
                let variable = variables.pop();
                event_step(variable.line, "remove_variable", variable.name)
            }
        } else if (run_object.kind === "declaration") {
            for (const exec_element of run_object.exec) {
                let variable_name = exec_element.exec.name;
                let variable_value = exec_element.exec.undefined ? "undefined" : walk(exec_element.exec.value)
                let variable = new_variable(exec_element.line, variable_name, variable_value);
                variables.push(variable)
                event_step(variable.line, "add_variable", variable.name, variable.value)
                variables_count[variables_count.length - 1]++;
            }
        } else if (run_object.kind === "if") {
            let condition = walk(run_object.exec[0]);
            if (condition) {
                walk(run_object.exec[1])
            }
        } else if (run_object.kind === "for") {
            variables_count.push(0);

            walk(run_object.exec[0])
            while (walk(run_object.exec[1])) {
                walk(run_object.exec[3]);
                walk(run_object.exec[2]);
            }

            let count = variables_count.pop();
            while (count > 0) {
                count -= 1;
                let variable = variables.pop();
                event_step(variable.line, "remove_variable", variable.name)
            }
        } else if (run_object.kind === "while") {
            while (walk(run_object.exec[0])) {
                walk(run_object.exec[1]);
            }
        } else if (run_object.kind === "expression") {
            let kind = run_object.exec.kind;
            if (kind === "number") {
                return run_object.exec.value;
            } else if (kind === "assignment") {
                let variable_name = run_object.exec.name;
                let variable = get_variable(variable_name);
                let value = walk(run_object.exec.value);
                let operator = run_object.exec.sub;
                if (operator === "=") {
                    variable.value = value;
                } else if (operator === "+=") {
                    variable.value += value;
                } else if (operator === "-=") {
                    variable.value -= value;
                } else if (operator === "*=") {
                    variable.value *= value;
                } else if (operator === "%=") {
                    variable.value %= value;
                } else if (operator === "/=") {
                    variable.value /= value;
                    variable.value |= 0;
                }
                event_step(variable.line, "update_variable", variable_name, variable.value);
                return variable.value;
            } else if (kind === "variable_access") {
                let variable_name = run_object.exec.name;
                let variable = get_variable(variable_name);
                return variable.value;
            } else if (kind === "leading_unary") {
                let variable_name = run_object.exec.name
                let operator = run_object.exec.sub;
                let variable = get_variable(variable_name);
                if (operator === "++") {
                    variable.value += 1;
                    event_step(variable.line, "update_variable", variable_name, variable.value);
                    return variable.value;
                } else if (operator === "--") {
                    variable.value -= 1;
                    event_step(variable.line, "update_variable", variable_name, variable.value);
                    return variable.value;
                } else {
                    return undefined;
                }
            } else if (kind === "trailing_unary") {
                let variable_name = run_object.exec.name
                let operator = run_object.exec.sub;
                let variable = get_variable(variable_name);
                if (operator === "++") {
                    variable.value += 1;
                    event_step(variable.line, "update_variable", variable_name ,variable.value);
                    return variable.value - 1;
                } else if (operator === "--") {
                    variable.value -= 1;
                    event_step(variable.line, "update_variable", variable_name, variable.value);
                    return variable.value + 1;
                } else {
                    return undefined;
                }
            } else if (kind === "binary") {
                let left = walk(run_object.exec.left);
                let right = walk(run_object.exec.right);
                let operator = run_object.exec.sub;
                if (operator === "+") {
                    return left + right;
                } else if (operator === "-") {
                    return left - right;
                } else if (operator === "*") {
                    return left * right;
                } else if (operator === "%") {
                    return left % right;
                } else if (operator === "/") {
                    return (left / right) | 0;
                } else {
                    return undefined;
                }
            } else {
                return undefined;
            }
        } else if (run_object.kind === "condition") {
            let left = walk(run_object.exec.left);
            let right = walk(run_object.exec.right);
            let operator = run_object.exec.sub;
            if (operator === "==") {
                return left === right;
            } else if (operator === "<") {
                return left < right;
            } else if (operator === ">") {
                return left > right;
            } else if (operator === "<=") {
                return left <= right;
            } else if (operator === ">=") {
                return left >= right;
            } else {
                return undefined;
            }
        } else {
            console.log("oh, what is this");
            return undefined;
        }
    }

    walk(runnable);


</script>

</body>
</html>